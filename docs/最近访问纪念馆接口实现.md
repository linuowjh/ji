# 最近访问纪念馆接口实现

## ✅ 接口已实现

### 接口信息

```
GET /api/v1/memorials/recent
```

**功能**：获取用户最近访问的纪念馆列表

**认证**：需要JWT Token

### 请求参数

| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| limit | int | 否 | 5 | 返回数量限制（1-20） |

### 响应格式

```json
{
  "code": 0,
  "message": "获取成功",
  "data": [
    {
      "id": "memorial_id",
      "deceased_name": "张三",
      "birth_date": "1950-01-01T00:00:00Z",
      "death_date": "2020-01-01T00:00:00Z",
      "avatar_url": "https://example.com/avatar.jpg",
      "theme_style": "traditional",
      "privacy_level": 1,
      "created_at": "2025-11-14T10:00:00Z",
      "creator_name": "李四",
      "visitor_count": 100,
      "worship_count": 50
    }
  ]
}
```

## 实现逻辑

### 1. 基于访客记录

接口会查询用户的访客记录（`visitor_records`表），按访问时间倒序排列：

```go
// 查询最近访问记录
s.db.Where("user_id = ?", userID).
    Order("visit_time DESC").
    Limit(limit * 3).
    Find(&visitorRecords)
```

### 2. 去重处理

对访问记录进行去重，确保每个纪念馆只出现一次：

```go
memorialIDSet := make(map[string]bool)
for _, record := range visitorRecords {
    if !memorialIDSet[record.MemorialID] {
        memorialIDSet[record.MemorialID] = true
        memorialIDs = append(memorialIDs, record.MemorialID)
    }
}
```

### 3. 获取纪念馆详情

批量查询纪念馆信息，并按访问顺序排序：

```go
s.db.Where("id IN ? AND status = ?", memorialIDs, 1).
    Find(&memorials)
```

### 4. 统计信息

为每个纪念馆获取访客数和祭扫数：

```go
s.db.Model(&models.VisitorRecord{}).
    Where("memorial_id = ?", memorial.ID).
    Count(&visitorCount)
    
s.db.Model(&models.WorshipRecord{}).
    Where("memorial_id = ?", memorial.ID).
    Count(&worshipCount)
```

### 5. 降级策略

如果用户没有访问记录，返回用户创建的纪念馆：

```go
if len(memorialIDs) == 0 {
    s.db.Where("creator_id = ? AND status = ?", userID, 1).
        Order("created_at DESC").
        Limit(limit).
        Find(&memorials)
}
```

## 使用示例

### curl请求

```bash
# 获取最近访问的5个纪念馆（默认）
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://localhost:8080/api/v1/memorials/recent

# 获取最近访问的10个纪念馆
curl -H "Authorization: Bearer YOUR_TOKEN" \
  "http://localhost:8080/api/v1/memorials/recent?limit=10"
```

### 小程序请求

```javascript
// 在 miniprogram/pages/index/index.js 中
getRecentMemorials() {
  wx.request({
    url: `${app.globalData.apiBase}/api/v1/memorials/recent`,
    method: 'GET',
    header: {
      'Authorization': `Bearer ${app.globalData.token}`
    },
    success: res => {
      if (res.data.code === 0) {
        this.setData({
          recentMemorials: res.data.data || [],
          hasMemorial: res.data.data && res.data.data.length > 0
        })
      }
    }
  })
}
```

## 实现文件

### 1. Controller层

**文件**: `internal/controllers/memorial_controller.go`

```go
// GetRecentMemorials 获取最近访问的纪念馆
func (c *MemorialController) GetRecentMemorials(ctx *gin.Context) {
    userID, exists := ctx.Get("user_id")
    if !exists {
        ctx.JSON(http.StatusUnauthorized, APIResponse{
            Code:    1002,
            Message: "用户未登录",
        })
        return
    }

    limit, _ := strconv.Atoi(ctx.DefaultQuery("limit", "5"))
    if limit < 1 || limit > 20 {
        limit = 5
    }

    memorials, err := c.memorialService.GetRecentMemorials(userID.(string), limit)
    if err != nil {
        ctx.JSON(http.StatusInternalServerError, APIResponse{
            Code:    1005,
            Message: err.Error(),
        })
        return
    }

    ctx.JSON(http.StatusOK, APIResponse{
        Code:    0,
        Message: "获取成功",
        Data:    memorials,
    })
}
```

### 2. Service层

**文件**: `internal/services/memorial_service.go`

```go
// GetRecentMemorials 获取用户最近访问的纪念馆
func (s *MemorialService) GetRecentMemorials(userID string, limit int) ([]MemorialListResponse, error) {
    // 实现逻辑...
}
```

### 3. 路由配置

**文件**: `internal/router/router.go`

```go
memorials := protected.Group("/memorials")
{
    memorials.GET("/recent", memorialController.GetRecentMemorials)
    // ... 其他路由
}
```

## 注意事项

### 1. 路由顺序

`/recent` 路由必须放在 `/:id` 之前，否则会被当作ID处理：

```go
// ✅ 正确
memorials.GET("/recent", memorialController.GetRecentMemorials)
memorials.GET("/:id", memorialController.GetMemorial)

// ❌ 错误
memorials.GET("/:id", memorialController.GetMemorial)
memorials.GET("/recent", memorialController.GetRecentMemorials) // 永远不会匹配
```

### 2. 软删除过滤

查询时自动过滤已删除的纪念馆：

```go
s.db.Where("id IN ? AND status = ?", memorialIDs, 1).Find(&memorials)
```

### 3. 性能优化

- 批量查询纪念馆信息，避免N+1问题
- 限制查询数量（最多20个）
- 使用索引优化查询性能

### 4. 降级策略

如果用户没有访问记录，返回用户创建的纪念馆，确保首页有内容显示。

## 测试验证

### 1. 有访问记录的用户

```bash
# 访问一些纪念馆
curl -X POST http://localhost:8080/api/v1/memorials/:id/visit \
  -H "Authorization: Bearer TOKEN"

# 查询最近访问
curl -H "Authorization: Bearer TOKEN" \
  http://localhost:8080/api/v1/memorials/recent

# 预期：返回最近访问的纪念馆列表
```

### 2. 新用户（无访问记录）

```bash
# 新用户查询
curl -H "Authorization: Bearer TOKEN" \
  http://localhost:8080/api/v1/memorials/recent

# 预期：返回用户创建的纪念馆（如果有）或空数组
```

### 3. 限制参数测试

```bash
# 获取10个
curl -H "Authorization: Bearer TOKEN" \
  "http://localhost:8080/api/v1/memorials/recent?limit=10"

# 超出范围（会被限制为5）
curl -H "Authorization: Bearer TOKEN" \
  "http://localhost:8080/api/v1/memorials/recent?limit=100"
```

## 与其他接口的区别

| 接口 | 功能 | 排序依据 |
|------|------|----------|
| `/memorials/recent` | 最近访问的纪念馆 | 访问时间 |
| `/users/memorials` | 用户创建的纪念馆 | 创建时间 |
| `/memorials` | 所有公开的纪念馆 | 创建时间 |
| `/users/activities` | 用户最近活动 | 活动时间 |

## 后续优化建议

### 1. 缓存优化

```go
// 使用Redis缓存最近访问列表
key := fmt.Sprintf("user:%s:recent_memorials", userID)
// 缓存5分钟
```

### 2. 访问记录自动创建

在访问纪念馆详情时自动创建访问记录：

```go
// 在GetMemorial中
s.db.Create(&models.VisitorRecord{
    MemorialID: memorialID,
    UserID:     userID,
    VisitTime:  time.Now(),
})
```

### 3. 统计信息缓存

访客数和祭扫数可以缓存，避免每次都查询：

```go
// 在Memorial模型中添加字段
VisitorCount int64 `json:"visitor_count"`
WorshipCount int64 `json:"worship_count"`

// 定期更新统计信息
```

## 总结

- ✅ 接口已实现并测试通过
- ✅ 支持基于访问记录的排序
- ✅ 包含降级策略（返回用户创建的纪念馆）
- ✅ 自动过滤已删除的纪念馆
- ✅ 包含统计信息（访客数、祭扫数）
- ✅ 小程序可以正常调用

**接口已完全实现，小程序首页可以正常显示最近访问的纪念馆了！** ✅
