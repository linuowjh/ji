# 软删除关联查询问题修复

## 问题描述

### 错误现象

登录成功后，调用用户最近活动接口返回错误：

```json
{
  "code": 3001,
  "message": "纪念馆不存在"
}
```

### 问题原因

1. **软删除机制**
   - Memorial模型使用了GORM的软删除（`DeletedAt`字段）
   - 当纪念馆被删除后，记录仍在数据库中，但`deleted_at`字段不为NULL

2. **关联查询问题**
   - 在 `GetUserRecentActivities` 中使用 `Preload("Memorial")` 加载关联数据
   - 如果用户的祭扫记录关联的纪念馆已被软删除
   - Preload会尝试加载已删除的记录，导致查询失败

3. **错误传播**
   - 查询失败后返回"纪念馆不存在"错误
   - 导致整个接口返回3001错误码

### 问题场景

```
用户A创建了纪念馆M
用户A进行了祭扫活动
纪念馆M被删除（软删除）
用户A登录后查询最近活动
→ 尝试加载纪念馆M的信息
→ 发现纪念馆已删除
→ 返回错误
```

## 解决方案

### 修改内容

在 `internal/services/user_service.go` 的 `GetUserRecentActivities` 函数中：

#### 修改前

```go
// 获取最近的祭扫记录
var worshipRecords []models.WorshipRecord
s.db.Where("user_id = ?", userID).
    Preload("Memorial").  // ❌ 会加载已删除的纪念馆
    Order("created_at DESC").
    Limit(limit).
    Find(&worshipRecords)

for _, record := range worshipRecords {
    activity := map[string]interface{}{
        "type":       "worship",
        "action":     record.WorshipType,
        "memorial":   record.Memorial,  // ❌ 可能是已删除的纪念馆
        "created_at": record.CreatedAt,
    }
    activities = append(activities, activity)
}
```

#### 修改后

```go
// 获取最近的祭扫记录
var worshipRecords []models.WorshipRecord
s.db.Where("user_id = ?", userID).
    Preload("Memorial", "deleted_at IS NULL").  // ✅ 只加载未删除的纪念馆
    Order("created_at DESC").
    Limit(limit).
    Find(&worshipRecords)

for _, record := range worshipRecords {
    // ✅ 跳过纪念馆已被删除的记录
    if record.Memorial.ID == "" {
        continue
    }
    activity := map[string]interface{}{
        "type":       "worship",
        "action":     record.WorshipType,
        "memorial":   record.Memorial,
        "created_at": record.CreatedAt,
    }
    activities = append(activities, activity)
}
```

### 关键改进

1. **Preload条件过滤**
   ```go
   Preload("Memorial", "deleted_at IS NULL")
   ```
   只加载未删除的纪念馆

2. **空值检查**
   ```go
   if record.Memorial.ID == "" {
       continue
   }
   ```
   跳过纪念馆已被删除的记录

3. **家族活动同样处理**
   ```go
   Preload("Family", "deleted_at IS NULL")
   Preload("Memorial", "deleted_at IS NULL")
   ```

## 测试验证

### 测试场景1：正常情况

```bash
# 用户有活动，纪念馆未删除
GET /api/v1/users/recent-activities

# 预期响应
{
  "code": 0,
  "message": "获取成功",
  "data": [
    {
      "type": "worship",
      "action": "flower",
      "memorial": {
        "id": "memorial_id",
        "deceased_name": "张三"
      },
      "created_at": "2025-11-14T10:00:00Z"
    }
  ]
}
```

### 测试场景2：纪念馆已删除

```bash
# 用户有活动，但纪念馆已被删除
GET /api/v1/users/recent-activities

# 预期响应（跳过已删除的纪念馆）
{
  "code": 0,
  "message": "获取成功",
  "data": []  // 或者只包含未删除纪念馆的活动
}
```

### 测试场景3：混合情况

```bash
# 用户有多个活动，部分纪念馆已删除
GET /api/v1/users/recent-activities

# 预期响应（只返回未删除纪念馆的活动）
{
  "code": 0,
  "message": "获取成功",
  "data": [
    {
      "type": "worship",
      "memorial": { "id": "memorial_1" }  // 未删除
    }
    // memorial_2 已删除，不返回
  ]
}
```

## GORM软删除机制

### 什么是软删除

软删除是一种数据删除策略：
- 不真正删除数据库记录
- 而是设置 `deleted_at` 字段为删除时间
- 查询时自动过滤已删除的记录

### GORM软删除字段

```go
type Memorial struct {
    // ... 其他字段
    DeletedAt gorm.DeletedAt `json:"-" gorm:"index;comment:删除时间"`
}
```

### GORM自动过滤

```go
// 普通查询会自动过滤软删除的记录
db.Find(&memorials)  // WHERE deleted_at IS NULL

// 包含软删除的记录
db.Unscoped().Find(&memorials)  // 不过滤deleted_at
```

### Preload的软删除处理

```go
// ❌ 默认Preload不会自动过滤软删除
db.Preload("Memorial").Find(&records)

// ✅ 需要显式指定条件
db.Preload("Memorial", "deleted_at IS NULL").Find(&records)
```

## 其他需要注意的地方

### 1. 所有关联查询都要检查

查找项目中所有使用 `Preload` 的地方：

```bash
grep -r "Preload" internal/services/
```

确保对软删除模型的Preload都添加了条件。

### 2. 常见的软删除模型

项目中使用软删除的模型：
- `Memorial` - 纪念馆
- `Family` - 家族
- `User` - 用户
- 其他有 `DeletedAt` 字段的模型

### 3. 统一的Preload模式

建议创建辅助函数：

```go
// 在 internal/services/helpers.go
func PreloadActiveMemorial(db *gorm.DB) *gorm.DB {
    return db.Preload("Memorial", "deleted_at IS NULL")
}

func PreloadActiveFamily(db *gorm.DB) *gorm.DB {
    return db.Preload("Family", "deleted_at IS NULL")
}

// 使用
s.db.Where("user_id = ?", userID).
    Scopes(PreloadActiveMemorial).
    Find(&records)
```

## 最佳实践

### 1. Preload软删除模型

```go
// ✅ 正确
db.Preload("Memorial", "deleted_at IS NULL")

// ❌ 错误
db.Preload("Memorial")
```

### 2. 检查关联是否存在

```go
// ✅ 正确
if record.Memorial.ID == "" {
    continue  // 跳过
}

// ❌ 错误
// 直接使用，可能导致空指针
memorial := record.Memorial
```

### 3. 提供友好的错误信息

```go
// ✅ 正确
if len(activities) == 0 {
    return []map[string]interface{}{}, nil  // 返回空数组，不是错误
}

// ❌ 错误
if len(activities) == 0 {
    return nil, fmt.Errorf("没有活动记录")  // 不应该是错误
}
```

### 4. 日志记录

```go
// 记录跳过的记录
if record.Memorial.ID == "" {
    log.Printf("跳过已删除纪念馆的活动记录: worship_id=%s", record.ID)
    continue
}
```

## 相关问题排查

### 如何确认是软删除问题

1. **查看数据库**
   ```sql
   SELECT id, deleted_at FROM memorials WHERE id = 'memorial_id';
   ```

2. **检查日志**
   ```
   MYSQL_LOG_LEVEL=info
   ```
   查看SQL查询是否包含 `deleted_at IS NULL`

3. **测试Preload**
   ```go
   // 测试代码
   var record models.WorshipRecord
   db.Preload("Memorial").First(&record, "id = ?", recordID)
   fmt.Printf("Memorial ID: %s\n", record.Memorial.ID)
   ```

### 常见错误模式

1. **忘记添加Preload条件**
   ```go
   db.Preload("Memorial")  // ❌
   ```

2. **条件写错**
   ```go
   db.Preload("Memorial", "deleted_at = NULL")  // ❌ 应该用 IS
   ```

3. **没有检查空值**
   ```go
   memorial := record.Memorial  // ❌ 可能为空
   ```

## 总结

### 问题根源
- GORM的Preload默认不过滤软删除记录
- 需要显式添加条件

### 解决方案
- 在Preload中添加 `"deleted_at IS NULL"` 条件
- 检查关联对象是否为空
- 跳过已删除的记录

### 影响范围
- 所有使用Preload加载软删除模型的地方
- 特别是用户活动、统计等聚合查询

### 预防措施
- 代码审查时检查Preload用法
- 创建辅助函数统一处理
- 添加单元测试覆盖软删除场景

**修复后，即使纪念馆被删除，用户最近活动接口也能正常工作！** ✅
